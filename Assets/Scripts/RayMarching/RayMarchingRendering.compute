#pragma kernel CSMain
#pragma kernel CSMain DEBUG_DISTANCE
#pragma kernel CSMain DEBUG_NORMAL
#include "UnityCG.cginc"

#define THREAD_GROUP_SIZE_X 8
#define THREAD_GROUP_SIZE_Y 8
#define THREAD_GROUP_SIZE_Z 1
#define RAY_MARCHING_PRECISION 1.0e-3f
#define MAX_STEP 1024
#define MAX_INSTANCE_NUMBER 64

// Buffers
struct InstanceData {
    float4x4 transfom;
    float4x4 inverseTransfom;
    float3 scale;
    uint index;
    float4 color;
};

RWTexture2D<float4> _Result;
StructuredBuffer<InstanceData> _InstanceData;
uint _InstanceCount;

Texture3D<float4> _Volume0;
Texture3D<float4> _Volume1;
Texture3D<float4> _Volume2;
Texture3D<float4> _Volume3;
Texture3D<float4> _Volume4;
Texture3D<float4> _Volume5;
Texture3D<float4> _Volume6;
Texture3D<float4> _Volume7;
SamplerState linearClampSampler;

float4 _CameraPosition;
float4 _CameraParams;
float4x4 _FrustumCorners;
float3 _SkyColor;
float3 _AmbientColor;
float _GroundLevel;
float3 _GroundColor;
float3 _LightColor;
float4 _LightPosition;

// Functions
float2 GetTexcoord (uint3 id, uint width, uint height) {
    float2 texelSize = rcp(float2(width, height));
    float2 texcoord = float2(id.xy) + 0.5;
    texcoord *= texelSize;
    return texcoord;
}

float3 GetRayDirection (float2 uv) {
    // world space direction
    float3 direction = _FrustumCorners[0].xyz +
    (_FrustumCorners[3].xyz - _FrustumCorners[0].xyz) * uv.x +
    (_FrustumCorners[1].xyz - _FrustumCorners[0].xyz) * uv.y;
    return normalize(direction);
}

float RayGroundIntersect(float3 origin, float3 direction, float height)
{
    const float3 n = float3(0.0, 1.0, 0.0);
    return -(dot(origin, n) - height) / dot(direction, n);
}

float SdBox(float3 position, float3 center, float3 size)
{
    float3 q = abs(position - center) - size;
    return length(max(q, 0.0)) + min(max(max(q.x, q.y) ,q.z), 0.0);
}

float SampleSdfVolume(uint index, float3 position) {
    switch(index) {
        case 0:
        return _Volume0.SampleLevel(linearClampSampler, position + 0.5, 0) * 2.0 - 1.0;
        case 1:
        return _Volume1.SampleLevel(linearClampSampler, position + 0.5, 0) * 2.0 - 1.0;
        case 2:
        return _Volume2.SampleLevel(linearClampSampler, position + 0.5, 0) * 2.0 - 1.0;
        case 3:
        return _Volume3.SampleLevel(linearClampSampler, position + 0.5, 0) * 2.0 - 1.0;
        case 4:
        return _Volume4.SampleLevel(linearClampSampler, position + 0.5, 0) * 2.0 - 1.0;
        case 5:
        return _Volume5.SampleLevel(linearClampSampler, position + 0.5, 0) * 2.0 - 1.0;
        case 6:
        return _Volume6.SampleLevel(linearClampSampler, position + 0.5, 0) * 2.0 - 1.0;
        case 7:
        return _Volume7.SampleLevel(linearClampSampler, position + 0.5, 0) * 2.0 - 1.0;
        default:
        return 0.0;
    }
}

float GetSdfVolumeDimensions(uint index) {
    uint3 dims = 0;
    switch(index) {
        case 0:
        _Volume0.GetDimensions(dims.x, dims.y, dims.z);
        break;
        case 1:
        _Volume1.GetDimensions(dims.x, dims.y, dims.z);
        break;
        case 2:
        _Volume2.GetDimensions(dims.x, dims.y, dims.z);
        break;
        case 3:
        _Volume3.GetDimensions(dims.x, dims.y, dims.z);
        break;
        case 4:
        _Volume4.GetDimensions(dims.x, dims.y, dims.z);
        break;
        case 5:
        _Volume5.GetDimensions(dims.x, dims.y, dims.z);
        break;
        case 6:
        _Volume6.GetDimensions(dims.x, dims.y, dims.z);
        break;
        case 7:
        _Volume7.GetDimensions(dims.x, dims.y, dims.z);
        break;
    }
    return dims;
}

float SampleDistance(uint instanceIndex, float3 position) {
    InstanceData instanceData = _InstanceData[instanceIndex];
    float3 p = mul(instanceData.inverseTransfom, float4(position, 1.0)).xyz / instanceData.scale;
    float d1 = SdBox(p, 0.0, 0.5);
    float d2 = SampleSdfVolume(instanceData.index, p);
    float s = min(min(instanceData.scale.x, instanceData.scale.y), instanceData.scale.z);
    if (d1 < 0.0) {
        return d2 * s;
    }
    else {
        return (d1 + d2) * s;
    }
}

float SampleDistanceScene(float3 position, out uint instanceIndex) {
    float minDistance = 1.0e7f;
    instanceIndex = MAX_INSTANCE_NUMBER;
    for (uint i = 0; i < _InstanceCount; ++i) {
        float d = SampleDistance(i, position);
        if (d < minDistance) {
            minDistance = d;
            instanceIndex = i;
        }
    }
    return minDistance;
}

float3 SampleNormal(uint instanceIndex, float3 position) {
    // ref: https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm
    InstanceData instanceData = _InstanceData[instanceIndex];
    uint index = instanceData.index;
    float3 p = mul(instanceData.inverseTransfom, float4(position, 1.0)).xyz / instanceData.scale;
    
    const float h = 1.0 / GetSdfVolumeDimensions(index).x;
    const float2 k = float2(1.0, -1.0);
    float3 n =
    k.xyy * SampleSdfVolume(index, p + k.xyy * h) +
    k.yyx * SampleSdfVolume(index, p + k.yyx * h) +
    k.yxy * SampleSdfVolume(index, p + k.yxy * h) +
    k.xxx * SampleSdfVolume(index, p + k.xxx * h);
    n = mul((float3x3)instanceData.transfom, n / instanceData.scale);
    return normalize(n);
}

float3 Shading(float3 color, float3 lightColor, float3 n, float3 l, float3 v) {
    float3 h = normalize(l + v);
    float nl = max(0, dot(n, l));
    float nh = max(0, dot(n, h));
    return color * lightColor * nl + lightColor * pow(nh, 128);
}

// Kernels
[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void CSMain (
in uint3 dispatchThreadID : SV_DispatchThreadID, // DispatchThreadID  = dot(GroupID, numthreads) + GroupThreadId;
in uint  groupIndex       : SV_GroupIndex, // uint GroupIndex = unique index of a thread inside a group
in uint3 groupID          : SV_GroupID, // GroupID = index for each dimension inside a ThreadGroupCount
in uint3 groupThreadID    : SV_GroupThreadID // uint3 GroupThreadId = indices for each dimension inside a group of the current thread
) {
    uint width, height;
    _Result.GetDimensions(width, height);

    if (dispatchThreadID.x >= width || dispatchThreadID.y >= height) { return; }

    float2 uv = GetTexcoord(dispatchThreadID, width, height);
    float3 direction = GetRayDirection(uv);
    float3 origin = _CameraPosition + direction * _CameraParams.x;
    
    float3 color = 0.0;
    float3 position = 0.0;
    float3 normal = 0.0;
    float max_t = RayGroundIntersect(origin, direction, _GroundLevel);
    if (max_t < 0.0) {
        color = _SkyColor; // sky
        max_t = _CameraParams.y - _CameraParams.x;
    }
    else {
        color = _GroundColor; // ground
        normal = float3(0.0, 1.0, 0.0);
    }

    float t = 0.0;
    uint i , instanceIndex;
    for (i = 0; i < MAX_STEP; ++i) {
        if (t > max_t) {
            break;
        }

        position = origin + direction * t;
        float distance = SampleDistanceScene(position, /*out*/ instanceIndex);
        if (distance < RAY_MARCHING_PRECISION && distance > -RAY_MARCHING_PRECISION) {
            color = _InstanceData[instanceIndex].color.rgb;
            normal = SampleNormal(instanceIndex, position);
            break;
        }
        else {
            t += distance;
        }
    }

#if defined DEBUG_DISTANCE
    if (t > max_t && normal.y > 0.0) {
        float distance = SampleDistanceScene(origin + direction * max_t, instanceIndex);
        color = frac(distance * 10.0);
    }
#elif defined DEBUG_NORMAL
    if (any(normal)){
        color = normal * 0.5 + 0.5;
    }
#else
    if (t > max_t) {
        if(normal.y > 0.0) {
            position = origin + direction * max_t;
        }
        else {
            _Result[dispatchThreadID.xy] = float4(color.rgb, 1.0f);
            return;
        }
    }

    float3 lightColor = _LightColor;
    float3 view = normalize(_CameraPosition - position);
    direction = lerp(_LightPosition.xyz, _LightPosition.xyz - position, _LightPosition.w); // light direction
    if (_LightPosition.w > 0.5) {
        // point light's attenuation
        float len = length(direction);
        lightColor *= rcp(1.0 + 0.045 * len + 0.0075 * len * len);
        direction /= len;
    }
    
    origin = position + normal * RAY_MARCHING_PRECISION;
    max_t = _CameraParams.y - _CameraParams.x;
    t = RAY_MARCHING_PRECISION * 5.0;
    float shadow = 1.0;
    for (i = 0; i < MAX_STEP; ++i) {
        if (t > max_t) {
            break;
        }

        position = origin + direction * t;
        float distance = SampleDistanceScene(position, /*out*/ instanceIndex);
        if (distance < RAY_MARCHING_PRECISION && distance > -RAY_MARCHING_PRECISION) {
            shadow = 0.0;
            break;
        }
        else {
            const float k = 32.0;
            shadow = min(shadow, k * distance / t );
            t += distance;
        }
    }

    color = color * (Shading(color, lightColor, normal, direction, view) * shadow + _AmbientColor);
#endif

    _Result[dispatchThreadID.xy] = float4(color.rgb, 1.0f);
}

